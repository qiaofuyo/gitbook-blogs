# JS运行机制

## 任务队列

> 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
>
> **任务队列** 中放置的是 异步任务的事件 和 定时事件（即指定某些代码在多少时间之后执行）。

同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务的回调函数可以执行了，该任务才会进入主线程执行。

```text
JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。
```

**小结：**只要主线程（执行栈，执行上下文栈，这是同步任务）的代码执行完毕，就会去读取“任务队列”（这是异步任务）中的事件（IO事件和由用户产生的事件，如鼠标点击、页面滚动等），依次执行那些事件所对应的回调函数（即读取执行完异步任务后的回调函数）。

## Event Loop

> 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行。

只有当前脚本的所有代码执行完（同步任务执行完），系统才会去读取"任务队列"。 也就是说，指定回调函数的部分可以在向服务器发送数据的前或后，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取"任务队列"。

## 宏任务与微任务

> **任务队列** 中存放的是已经完成的异步任务结果（即事件），每个事件又称为 **宏任务**。
>
> **宏任务** 在执行过程中，是可以添加一些 **微任务**（即在处理事件的时候，事件内部另外有事件或任务需要处理）；在当前的微任务没有执行完成时，是不会执行下一个宏任务的。

**微任务** 是 **宏任务** 的一个步骤，所以先执行 **宏任务** 然后逐条执行当前所有的 **微任务**，然后执行下一条 **宏任务**。（宏任务是宿主级别，微任务是JS级别，它们是包含关系）。

宿主环境提供的方法是宏任务，例如setTimeout、setInterval。这些都是浏览器或者Node环境实现的。js引擎自身提供的是微任务，例如Promise。基本上平时接触到的除了Promise都是宏任务。

## 定时器

> 定时器功能主要由setTimeout\(\)和setInterval\(\)这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。

setTimeout\(\)最短间隔在激活的选项卡中是 **4ms**，在未激活的选项卡中是 **1000ms**。

setTimeout\(\)只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout\(\)指定的时间执行。

